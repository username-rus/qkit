## Введение
В данном разделе приводятся общее описание дизайна возможностей и назначения фреймворка.

## Цели проекта
Основной целью является создание инструмента, позволяющего производить обращение к функциям, вне зависимости от того, в каком глобальном контексте исполнения они находятся. При этом, механизм такого обращения, должен сохранять вид и логику работы обычной синхронной функции. Так же управление кодом на всех этапах. То есть описание, загрузка с условием, размещение и доступ во время исполнения и прочие.

## Пояснения к версии 0.2.0
Изначально концепция была в том, что бы перевести полностью все вызовы функций на "асинхронные рельсы", что бы обычные синхронные функции остались только в качестве приватных (служебных). Но это сильно снижает производительность, даже без учета межконтекстных пересылок - при вызовах в одном и том же глобальном контексте. Накладные расходы на `любую` реализацию асинхронного вызова, сохраняющего принцип работы синхронной функции, слишком большие. Большие по сравнению с обычным синхронным вызовом, и обойти это в принципе не возможно. 
Поэтому принята новая концепция, учитывающее это принципиальное ограничение. Теперь весь код будет делится на медленный (управляющий) и быстрый (вычислительный). 
Медленный (управляющий) это те же специально оформленные асинхронные функции, только теперь они не универсальные, а предназначены управлять всем ходом асинхронных многопоточных вычислений.
Быстрый (вычислительный) это обычные синхронные функции, только "упакованные" в виде специальных сущностей, с рядом фишек в будующих версиях.
Так же есть возможность загружать и использовать "произвольный код". То есть выполненный вне данного фреймворка, jquery, underscore и т.д. Это тот же быстрый код.
Еще point (точки) теперь представляют другую сущность (а именно "методы" frame/worker), выполнены и работают по другому.
На этом все важные замечания по данной версии.

## Используемые термины и сокращения
* Глобальный контекст исполнения (далее ГКИ) - или глобальный объект, то на что ссылается self
* Произвольный скрипт (код) - код построенный вне данного фреймворка
* Сервисы - условные наборы (связки) api фреймворка, предоставляющие вместе определенную функциональность
* Сущности - frame/worker/commandant/calculator/point
* Отдельный файл - файл для возможного размещения commandant/calculator/point
* Собственный файл - файл для frame/worker и возможного размещения commandant/calculator/point
* Определение (define) - создание новой сущности в файле
* Подключение (загрузка) - загрузка ранее определенных сущностей в ГКИ, при условии поддержки данной сущности со стороны ГКИ
* Использование терминов ООП - методы (возможные функции в составе сущности), поля (возможные данные в составе сущности), публичный (возможные методы и поля представляющие api сущности), приватный (возможные методы и поля со специальным обозначением, для рабочих вычислений сущности)

## Общий дизайн и возможности
* Введение в дизайн скриптов различного назначения (разделение на классы, классификация).
* Класс `frame` для `ГКИ` типа `iframe` и `gui thread` 
* Класс `worker` для `ГКИ` типа `dedicated worker`
* Класс `commandant` для асинхронной командной функциональности
* Класс `calculator` для синхронной вычислительной функциональности
* Класс `point` для приема и обработки асинхронных сообщений в `ГКИ` любых типов ("методы" frame/worker)
* Возможность обращения к функциональности любого commandant из любого `ГКИ`
* Возможность обращения к функциональности любого calculator только из того же `ГКИ` что и сам calculator
* Возможность обращения к любому `point` из любого `ГКИ`
* Встроенные поставщики идентификаторов, уникальных для любого `ГКИ`

## Правила использования
* Проектируйте свой проект так, что бы можно было однозначно выделить управляющий код (медленный) и вычислительный код (быстрый)
* Оформите управляющий код в виде commandant, поместите от одного до нескольких в `отдельный файл`
* Оформите вычислительный код в виде calculator, поместите от одного до нескольких в `отдельный файл`
* Определите сколько вам для данного проекта нужно frame, создайте `собственный файл` для каждого
* Определите сколько вам для данного проекта нужно worker, создайте `собственный файл` для каждого
* Необходимые point для каждого frame/worker поместите в `отдельный файл`, либо в `собственный файл` frame/worker
* gui thread (index) это обычный frame, так и оформляется
* Подключите в любой frame любые файлы с frame/worker/point/commandant/calculator
* Подключите в любой worker любые файлы с worker/point/commandant/calculator
* При необходимости, перенесите point/commandant/calculator из `отдельного файла` в `собственный файл` frame/worker

## Ограничения использования
* Нельзя подключать что либо внутри отдельного файла, только в собственный файл
* Нельзя подключать/определять commandant более одного раза на проект, он виден во всех ГКИ
* Нельзя определять несколько frame/worker в одном файле, это не имеет смысла
* Нужно подключать calculator для каждого ГКИ где он необходим, он виден только в этом ГКИ
* Нужно подключать произвольные скрипты в каждый ГКИ где они необходимы, и средствами фреймворка (QModule)
* Можно определять произвольного числа point/commandant/calculator в одном файле, как отдельном, так и собственном.
* Можно подключать одни и те же point в разные ГКИ, они видны во всех ГКИ, но под производными от frame/worker именами.

## Прочее
Глобальный объект Q - используется для хранения всех внутренних данных фреймворка. Не предназначен для взаимодействия с пользователем. Использование замыкания для данной цели отклонено из соображений производительности.
